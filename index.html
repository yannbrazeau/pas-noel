<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NoÃ«l chez les Brazo â€” Le Dernier Convive (Cluedo Cuisine)</title>

<style>
:root{
  --bg1:#0b1430;
  --bg2:#1a0b1e;
  --paper:#fff7ee;
  --ink:#1b1b1b;
  --gold:#d6b25e;
  --red:#c41e3a;
  --green:#1f7a4d;
}
*{box-sizing:border-box}
body{
  margin:0;
  padding:18px;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
  color:#fff;
  background:
    radial-gradient(900px 600px at 20% 0%, rgba(214,178,94,.20), transparent 60%),
    radial-gradient(900px 700px at 80% 10%, rgba(196,30,58,.18), transparent 55%),
    radial-gradient(1200px 900px at 50% 110%, rgba(31,122,77,.18), transparent 60%),
    linear-gradient(180deg, var(--bg1), var(--bg2));
}
.wrap{max-width:900px;margin:0 auto}
.card{
  background:var(--paper);
  color:var(--ink);
  border-radius:22px;
  padding:18px;
  box-shadow:0 18px 40px rgba(0,0,0,.35);
  border:1px solid rgba(0,0,0,.06);
  position:relative;
  margin:0 auto 16px;
}
.card:after{
  content:"";
  position:absolute;
  inset:10px;
  border-radius:16px;
  border:1px solid rgba(214,178,94,.55);
  pointer-events:none;
}
h1,h2{margin:0 0 10px}
h1{font-size:28px}
h2{font-size:18px}
.small{opacity:.78;font-size:14px;line-height:1.35}
.hr{height:1px;background:rgba(0,0,0,.10);margin:12px 0;border-radius:999px}

textarea,button{
  width:100%;
  padding:12px;
  border-radius:14px;
  border:1px solid rgba(0,0,0,.14);
  font-size:16px;
  margin-top:10px;
  background:#fff;
  color:#111;
}
button{
  cursor:pointer;
  font-weight:900;
  border:none;
  color:#fff;
  background:linear-gradient(180deg,#2aa565,#167347);
  box-shadow:0 10px 22px rgba(31,122,77,.20);
}
button.secondary{
  background:linear-gradient(180deg,#d63a4f,#a9122b);
  box-shadow:0 10px 22px rgba(196,30,58,.18);
}
button.reset{
  background:linear-gradient(180deg,#2b4aa5,#19357a);
  box-shadow:0 10px 22px rgba(11,74,158,.18);
}
.box{
  margin-top:12px;
  padding:12px;
  border-radius:16px;
  background:rgba(0,0,0,.05);
  border:1px dashed rgba(196,30,58,.35);
}
.pill{
  display:inline-block;
  padding:6px 10px;
  border-radius:999px;
  background:rgba(214,178,94,.18);
  border:1px solid rgba(214,178,94,.45);
  font-size:13px;
  margin:6px 6px 0 0;
}
a{color:#0b4a9e;word-break:break-all}
.hide{display:none}
kbd{
  display:inline-block;
  padding:2px 7px;
  border-radius:8px;
  border:1px solid rgba(0,0,0,.12);
  background:rgba(255,255,255,.8);
  font-size:12px;
}

/* Grille d'Ã©limination */
.grid-item{
  display:flex;
  align-items:center;
  gap:10px;
  margin:6px 0;
}
.grid-item input{ transform:scale(1.15); }
.grid-item.elim{ text-decoration:line-through; opacity:.6; }
.grid-head{ margin-top:10px; font-weight:800; }
.grid-actions{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  margin-top:10px;
}
.grid-actions button{
  width:auto;
  flex:1 1 220px;
  margin-top:0;
  padding:10px 12px;
  border-radius:12px;
  font-weight:900;
}

/* zone texte indices */
pre{
  margin:0;
  white-space:pre-wrap;
  font-family:inherit;
}

/* Pour Ã©viter les soucis de clics */
textarea,button{position:relative; z-index:5; pointer-events:auto}
</style>
</head>

<body>
<div class="wrap">

  <!-- HOST -->
  <div class="card" id="host">
    <h1>ğŸ„ NoÃ«l chez les Brazo</h1>
    <h2>ğŸ•¯ï¸ Le Dernier Convive â€” Cluedo Cuisine</h2>

    <div class="small">
      1) Mets <b>7 Ã  9 prÃ©noms</b> (1 par ligne)<br>
      2) Clique <b>GÃ‰NÃ‰RER</b><br>
      3) Envoie Ã  chacun son <b>lien privÃ©</b> (WhatsApp)<br>
      4) Pendant le repas, envoie au groupe les liens <b><kbd>?a=</kbd></b> pour synchroniser les actes
      <div class="hr"></div>
      <b>Ã€ dire au groupe :</b> â€œCâ€™est un Cluedo sur smartphone. Ne montrez pas votre Ã©cran. Au dessert : accusation finale.â€
    </div>

    <textarea id="names" placeholder="Yann&#10;Delphine&#10;Maxime&#10;Louis&#10;Gabriel&#10;Juliette&#10;Baptiste"></textarea>
    <button id="btnGen">GÃ‰NÃ‰RER LA PARTIE</button>

    <div class="box">
      <h2>ğŸ“œ RÃ¨gles (Ã  afficher / copier)</h2>
      <div class="small" id="rulesBox">
        <b>ğŸ•¯ï¸ RÃ¨gles (Cluedo sur smartphone)</b><br>
        â€¢ Objectif : trouver <b>ğŸ”ª le tueur + ğŸ“ le lieu + ğŸ´ lâ€™arme</b>.<br>
        â€¢ Vos indices sont surtout des <b>âŒ Ã©liminations</b> (â€œpas Xâ€).<br>
        â€¢ <b>Ne montrez pas votre Ã©cran.</b><br>
        â€¢ Ã€ chaque acte : vous pouvez partager <b>1 info</b> (ou rien).<br>
        â€¢ âš ï¸ Il peut y avoir <b>un faux indice</b> : recoupez.<br>
        â€¢ ğŸ° Dessert : <b>accusation finale</b> (tueur + lieu + arme) â†’ rÃ©vÃ©lation.
      </div>
    </div>

    <div class="box">
      <h2>ğŸ”— Liens privÃ©s joueurs</h2>
      <div id="links" class="small">â€”</div>
      <div class="small" style="margin-top:8px;opacity:.85">
        âš ï¸ Chaque joueur doit ouvrir son lien privÃ© <b>au moins une fois</b> (Ã§a enregistre son accÃ¨s).
      </div>
    </div>

    <div class="box">
      <h2>ğŸ“£ Liens de groupe (synchro des actes)</h2>
      <div id="actLinks" class="small">â€”</div>
      <div class="small" style="margin-top:8px;opacity:.85">
        Ã€ envoyer dans le groupe WhatsApp Ã  chaque Ã©tape : tout le monde verra le mÃªme acte.
      </div>
    </div>

    <div class="box">
      <h2>ğŸ§© Solution (hÃ´te)</h2>
      <div id="solution" class="small">â€”</div>
      <div class="small" style="margin-top:8px;opacity:.85">
        Ne rÃ©vÃ¨le quâ€™au dessert.
      </div>
    </div>
  </div>

  <!-- PLAYER -->
  <div class="card hide" id="player">
    <h1>ğŸ•¯ï¸ Le Dernier Convive</h1>
    <div class="small"><b>Joueur :</b> <span id="pname"></span> â€” Ne montre pas ton Ã©cran.</div>

    <div class="box">
      <h2>ğŸ“œ RÃ¨gles</h2>
      <div class="small">
        Objectif : trouver <b>ğŸ”ª le tueur + ğŸ“ le lieu + ğŸ´ lâ€™arme</b>.<br>
        Tes indices servent Ã  <b>Ã©liminer</b>. Au dessert : accusation finale.
      </div>
    </div>

    <div class="box">
      <h2>ğŸ­ Ton rÃ´le</h2>
      <div id="role" class="small">â€”</div>
      <div id="roleRule" class="small" style="margin-top:6px;opacity:.85">â€”</div>
    </div>

    <div class="box hide" id="killerBox">
      <h2>ğŸ”ª Ton objectif secret</h2>
      <div id="killerGoal" class="small"></div>
    </div>

    <div class="box">
      <h2 id="actTitle"></h2>
      <div id="story" class="small"></div>
      <div class="small" style="margin-top:8px;opacity:.85" id="actInstruction"></div>
    </div>

    <div class="box">
      <h2>ğŸ” Tes indices (privÃ©s)</h2>
      <pre id="clue" class="small"></pre>
    </div>

    <div class="box">
      <h2>ğŸ—‚ï¸ Ta grille de dÃ©duction (privÃ©e)</h2>

      <div class="grid-head">ğŸ”ª Suspects</div>
      <div id="gridSuspects"></div>

      <div class="grid-head">ğŸ“ Lieux</div>
      <div id="gridPlaces"></div>

      <div class="grid-head">ğŸ´ Armes</div>
      <div id="gridWeapons"></div>

      <div class="grid-actions">
        <button id="btnAutoFromClues" class="secondary" type="button">AUTO-Ã‰LIMINER Ã  partir de mes indices</button>
        <button id="btnClearGrid" class="reset" type="button">RÃ‰INITIALISER ma grille</button>
      </div>

      <div class="small" style="margin-top:8px;opacity:.85">
        ğŸ’¾ Tout est enregistrÃ© sur ton tÃ©lÃ©phone (personne ne voit ta grille).
      </div>
    </div>

    <button class="secondary" id="btnNext">ACTE SUIVANT</button>

    <!-- MODE TEST (auto-hide : visible seulement en test, jamais en mode ?a= pilotÃ©) -->
    <div class="box hide" id="testBox">
      <h2>ğŸ§¼ Mode test</h2>
      <div class="small">
        Si tu testes plusieurs joueurs sur <b>le mÃªme tÃ©lÃ©phone</b>, efface le joueur enregistrÃ© ici.
      </div>
      <button class="reset" id="btnReset">EFFACER LE JOUEUR SUR CE TÃ‰LÃ‰PHONE</button>
    </div>
  </div>

</div>

<script>
/* ===================== Utils ===================== */
function b64uEncode(obj){
  const json = JSON.stringify(obj);
  const bytes = new TextEncoder().encode(json);
  let bin = "";
  for (const b of bytes) bin += String.fromCharCode(b);
  return btoa(bin);
}
function b64uDecode(str){
  const bin = atob(str);
  const bytes = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
  const json = new TextDecoder().decode(bytes);
  return JSON.parse(json);
}
function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }
function cleanNames(raw){
  // dÃ©doublonne, ignore lignes vides, ignore lignes purement numÃ©riques
  const out = [];
  const seen = new Set();
  raw.split("\n").map(s=>s.trim()).filter(Boolean).forEach(n=>{
    if (/^\d+$/.test(n)) return;
    const key = n.toLowerCase();
    if (!seen.has(key)){ seen.add(key); out.push(n); }
  });
  return out;
}

/* ===================== Narratif / Actes ===================== */
const ACTS = [
  {
    title: "ğŸ¥‚ Acte I â€” ApÃ©ro",
    story: "On trinque. Les regards circulent. La partie commence sans bruit.",
    instruction: "ğŸ­ Consigne : observe qui rÃ©pÃ¨te, qui parle trop vite, qui valide trop facilement."
  },
  {
    title: "ğŸ½ï¸ Acte II â€” EntrÃ©e",
    story: "Un dÃ©tail cloche. Quelquâ€™un dÃ©tourne dÃ©jÃ  lâ€™attention.",
    instruction: "ğŸ­ Consigne : observe qui pose des questionsâ€¦ et qui les regrette."
  },
  {
    title: "ğŸ Acte III â€” Plat",
    story: "Les certitudes se forment. Les erreurs aussi.",
    instruction: "ğŸ­ Consigne : Ã©coute les affirmations trop sÃ»res. Demande â€œpourquoi ?â€."
  },
  {
    title: "ğŸ§€ Acte IV â€” Fromage",
    story: "Un indice paraÃ®t parfait. Parfois trop parfait.",
    instruction: "ğŸ­ Consigne : annonce une certitude (mÃªme fragile). Regarde qui saute dessus."
  },
  {
    title: "ğŸ° Acte V â€” Dessert",
    story: "DerniÃ¨re ligne droite. Les masques tombentâ€¦ ou se resserrent.",
    instruction: "ğŸ­ Consigne : accuse (tueur + lieu + arme). Puis attends la rÃ©vÃ©lation."
  }
];

/* ===================== Listes Cluedo Cuisine ===================== */
// Lieux (9)
const WHERE = [
  "Cuisine",
  "Salle Ã  manger",
  "Salon",
  "EntrÃ©e",
  "Couloir",
  "Terrasse / Balcon",
  "PrÃ¨s du frigo",
  "Point dâ€™eau / Ã©vier",
  "Plan de travail"
];

// Armes (9) â€” ustensiles/objets cuisine, â€œCluedo-likeâ€
const WEAPONS = [
  "Couteau de cuisine",
  "Louche",
  "Rouleau Ã  pÃ¢tisserie",
  "Attendrisseur Ã  viande",
  "PoÃªle en fonte",
  "Bouteille de vin",
  "Ciseaux de cuisine",
  "RÃ¢pe Ã  fromage",
  "Moulin Ã  poivre"
];

/* ===================== RÃ´les (optionnels, lÃ©gers) ===================== */
const ROLES = [
  { id:"observer",    label:"ğŸ•µï¸ Lâ€™Observateur",  rule:"Tu as un bonus dâ€™indice Ã  lâ€™apÃ©ro. Observe les micro-rÃ©actions.", extraClue:true },
  { id:"silent",      label:"ğŸ¤ Le Silencieux",   rule:"Ã€ lâ€™apÃ©ro, tu ne peux pas parler. Tu peux sourire, acquiescer, mais silence.", silentAct:0 },
  { id:"manipulator", label:"ğŸ­ Le Manipulateur", rule:"Tu as 1 faux indice crÃ©dible. Utilise-le pour orienter le groupe.", fakeClue:true },
  { id:"confident",   label:"ğŸ•¯ï¸ Le Confident",    rule:"Une fois, tu peux montrer UN indice Ã  quelquâ€™un. Choisis bien.", canShowOne:true },
  { id:"rusher",      label:"â³ Le PressÃ©",       rule:"Tu dois accuser avant le dessert, sinon tu perds (mÃªme si tu avais raison).", mustAccuseBeforeDessert:true }
];

const KILLER_GOALS = [
  "ÃŠtre accusÃ© par au moins 2 personnes.",
  "Faire accuser un innocent prÃ©cis.",
  "Ne jamais mentir explicitement (tu peux esquiver).",
  "Ne jamais Ãªtre nommÃ© avant le dessert."
];

const FLAVOR = [
  "ğŸ•¯ï¸ Un sourire arrive une demi-seconde trop tard.",
  "ğŸ•¯ï¸ Quelquâ€™un rÃ©pond avant la fin de la question.",
  "ğŸ•¯ï¸ Une hÃ©sitationâ€¦ puis une phrase trÃ¨s â€œpropreâ€.",
  "ğŸ•¯ï¸ Observe qui Ã©vite de citer des noms.",
  "ğŸ•¯ï¸ Une certitude apparaÃ®t sans preuve."
];

const STORAGE_KEY = "dlc_player_token_cluedo";
let payload = null;
let act = 0;

/* ===================== RÃ´les : map ===================== */
function buildRoleMap(names, killerName){
  // rÃ´les spÃ©ciaux : 7->2, 8->3, 9->4
  const n = names.length;
  const specialCount = clamp(n - 5, 2, 4);

  const chosen = shuffle([...ROLES]).slice(0, specialCount);

  const map = {};
  names.forEach(nm => map[nm] = { id:"detective", label:"ğŸ•¯ï¸ DÃ©tective", rule:"Ã‰limine suspects/lieux/armes. Recoupe. Accuse au dessert." });

  const shuffledNames = shuffle([...names]);
  chosen.forEach((r, idx) => { map[shuffledNames[idx]] = r; });

  // garde-fou : Ã©viter â€œManipulateurâ€ au tueur
  if (map[killerName]?.id === "manipulator"){
    const detective = names.find(nm => nm !== killerName && map[nm].id === "detective");
    if (detective){
      map[killerName] = { id:"detective", label:"ğŸ•¯ï¸ DÃ©tective", rule:"Ã‰limine suspects/lieux/armes. Recoupe. Accuse au dessert." };
      map[detective]  = ROLES.find(r=>r.id==="manipulator");
    }
  }
  return map;
}

/* ===================== GÃ©nÃ©ration ===================== */
function generate(){
  const names = cleanNames(document.getElementById("names").value);

  if (names.length < 7 || names.length > 9){
    alert("Il faut entre 7 et 9 prÃ©noms (lignes non vides).");
    return;
  }

  const killer = shuffle([...names])[0];
  const where  = shuffle([...WHERE])[0];
  const weapon = shuffle([...WEAPONS])[0];

  // Fausse piste (crÃ©dible) pour le Manipulateur
  const fakeKiller = shuffle(names.filter(n=>n!==killer))[0];
  const fakeWhere  = pick(WHERE.filter(w=>w!==where));
  const fakeWeapon = pick(WEAPONS.filter(w=>w!==weapon));

  document.getElementById("solution").innerHTML =
    `<b>ğŸ”ª ${killer}</b><br>ğŸ“ ${where}<br>ğŸ´ ${weapon}<br>
     <div class="small" style="margin-top:6px;opacity:.85">Fausse piste interne : ${fakeKiller} / ${fakeWhere} / ${fakeWeapon} (ne pas dire)</div>
     <span class="small">Ne rÃ©vÃ¨le quâ€™au dessert.</span>`;

  // Deck d'exclusions (Cluedo pur)
  const deck = [];
  for (const n of names)   if (n !== killer) deck.push(`âŒ Ce nâ€™est pas ${n}`);
  for (const w of WHERE)   if (w !== where)  deck.push(`âŒ Pas ${w}`);
  for (const a of WEAPONS) if (a !== weapon) deck.push(`âŒ Pas ${a}`);

  // Faux indices (orientent vers fausse piste)
  const fakeDeck = [
    `âŒ Ce nâ€™est pas ${fakeKiller}`,
    `âŒ Pas ${fakeWhere}`,
    `âŒ Pas ${fakeWeapon}`
  ];

  shuffle(deck);

  const base = location.origin + location.pathname;

  // Liens de groupe (actes)
  const actLinks = ACTS.map((a, idx) => {
    const url = base + "?a=" + idx;
    return `<div class="pill">${a.title}</div><div><a href="${url}">${url}</a></div><br>`;
  }).join("");
  document.getElementById("actLinks").innerHTML = actLinks;

  // RÃ´les
  const roleMap = buildRoleMap(names, killer);
  const killerGoal = pick(KILLER_GOALS);

  // Distribution d'indices : 2 par acte par joueur (10 par joueur)
  const players = names.length;
  const cardsPerPlayer = ACTS.length * 2; // 10
  const totalCardsNeeded = players * cardsPerPlayer;

  let mega = [...deck];
  while (mega.length < totalCardsNeeded) mega.push(pick(FLAVOR));
  shuffle(mega);

  const hands = {};
  names.forEach((nm, i) => {
    hands[nm] = mega.slice(i*cardsPerPlayer, i*cardsPerPlayer + cardsPerPlayer);
  });

  // Manipulateur reÃ§oit au moins 1 faux indice (acte II)
  const manipName = names.find(nm => roleMap[nm]?.id === "manipulator");
  if (manipName){
    const idx = 2; // 1Ã¨re carte acte II
    hands[manipName][idx] = pick(fakeDeck);
  }

  // Observateur : bonus Ã  lâ€™acte I
  const observerBonus = pick(deck.length ? deck : FLAVOR);

  // Liens privÃ©s
  let linksHTML = "";
  names.forEach((nm)=>{
    const role = roleMap[nm];
    const handFlat = hands[nm];

    const perAct = [];
    for (let a=0; a<ACTS.length; a++){
      perAct.push([handFlat[a*2], handFlat[a*2+1]].filter(Boolean));
    }

    const dataObj = {
      v: 3,
      n: nm,
      role,
      hand: perAct,
      killer: (nm === killer),
      killerGoal: (nm === killer) ? killerGoal : null,
      observerBonus: (role.id === "observer") ? observerBonus : null,
      allNames: names,
      allPlaces: WHERE,
      allWeapons: WEAPONS
    };

    const data = b64uEncode(dataObj);
    const url  = base + "?p=" + encodeURIComponent(data);

    linksHTML += `<div class="pill">${nm}</div><div><a href="${url}">${url}</a></div><br>`;
  });

  document.getElementById("links").innerHTML = linksHTML;
}

/* ===================== Grille d'Ã©limination ===================== */
function gridKey(kind){
  // kind: suspects / places / weapons
  return `dlc_grid_${payload.n}_${kind}`;
}
function loadSet(key){
  try { return new Set(JSON.parse(localStorage.getItem(key) || "[]")); }
  catch { return new Set(); }
}
function saveSet(key, set){
  localStorage.setItem(key, JSON.stringify([...set]));
}

function renderGrid(containerId, items, key){
  const box = document.getElementById(containerId);
  box.innerHTML = "";

  const set = loadSet(key);

  items.forEach(item=>{
    const row = document.createElement("div");
    row.className = "grid-item" + (set.has(item) ? " elim" : "");

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = set.has(item);

    cb.addEventListener("change", ()=>{
      const cur = loadSet(key);
      if (cb.checked) cur.add(item);
      else cur.delete(item);
      saveSet(key, cur);
      row.classList.toggle("elim", cb.checked);
    });

    const label = document.createElement("span");
    label.textContent = item;

    row.appendChild(cb);
    row.appendChild(label);
    box.appendChild(row);
  });
}

function renderAllGrids(){
  renderGrid("gridSuspects", payload.allNames,   gridKey("suspects"));
  renderGrid("gridPlaces",   payload.allPlaces,  gridKey("places"));
  renderGrid("gridWeapons",  payload.allWeapons, gridKey("weapons"));
}

function autoEliminateFromClues(){
  // Parse des cartes "âŒ Ce nâ€™est pas X" / "âŒ Pas Y"
  const allClues = [];
  (payload.hand || []).forEach(arr => (arr||[]).forEach(c => allClues.push(c)));
  if (payload.role?.id === "observer" && payload.observerBonus) allClues.push(payload.observerBonus);

  const sus = loadSet(gridKey("suspects"));
  const pla = loadSet(gridKey("places"));
  const wea = loadSet(gridKey("weapons"));

  for (const c of allClues){
    if (typeof c !== "string") continue;

    // "âŒ Ce nâ€™est pas X"
    const m1 = c.match(/^âŒ\s*Ce nâ€™est pas\s+(.+)$/i);
    if (m1){
      const name = m1[1].trim();
      if (payload.allNames.includes(name)) sus.add(name);
      continue;
    }

    // "âŒ Pas Y"
    const m2 = c.match(/^âŒ\s*Pas\s+(.+)$/i);
    if (m2){
      const item = m2[1].trim();
      if (payload.allPlaces.includes(item)) pla.add(item);
      if (payload.allWeapons.includes(item)) wea.add(item);
      continue;
    }
  }

  saveSet(gridKey("suspects"), sus);
  saveSet(gridKey("places"), pla);
  saveSet(gridKey("weapons"), wea);
  renderAllGrids();
  alert("Auto-Ã©limination faite âœ…");
}

function clearGrid(){
  localStorage.removeItem(gridKey("suspects"));
  localStorage.removeItem(gridKey("places"));
  localStorage.removeItem(gridKey("weapons"));
  renderAllGrids();
  alert("Grille rÃ©initialisÃ©e âœ…");
}

/* ===================== Player UI ===================== */
function renderAct(){
  document.getElementById("actTitle").textContent = ACTS[act].title;
  document.getElementById("story").textContent    = ACTS[act].story;
  document.getElementById("actInstruction").textContent = ACTS[act].instruction;

  document.getElementById("role").textContent = payload.role?.label || "ğŸ•¯ï¸ DÃ©tective";
  document.getElementById("roleRule").textContent = payload.role?.rule || "";

  if (payload.killer){
    document.getElementById("killerBox").classList.remove("hide");
    document.getElementById("killerGoal").textContent = payload.killerGoal || "â€”";
  } else {
    document.getElementById("killerBox").classList.add("hide");
  }

  const clues = (payload.hand && payload.hand[act]) ? payload.hand[act] : [];
  const lines = [];

  if (!clues.length){
    lines.push("Pas dâ€™indice personnel Ã  cet acte. Observe ğŸ™‚");
  } else {
    clues.forEach(c => lines.push("â€¢ " + c));
  }

  if (payload.role?.id === "observer" && act === 0 && payload.observerBonus){
    lines.push("");
    lines.push("ğŸ•µï¸ Bonus Observateur :");
    lines.push("â€¢ " + payload.observerBonus);
  }

  if (payload.role?.id === "silent" && act === 0){
    document.getElementById("roleRule").textContent =
      "ğŸ¤ Ã€ lâ€™apÃ©ro, tu ne peux pas parler. Tu peux sourire, acquiescer, mais silence total.";
  }

  document.getElementById("clue").textContent = lines.join("\n");
}

function nextAct(){
  if (act < ACTS.length - 1){
    act++;
    renderAct();
  } else {
    alert("Dernier acte. Fais ton accusation finale (tueur + lieu + arme), puis attends la rÃ©vÃ©lation ğŸ•¯ï¸");
  }
}

/**
 * Synchro sans serveur :
 * - Le joueur ouvre 1 fois son lien privÃ© ?p=... -> token stockÃ©.
 * - L'hÃ´te envoie au groupe ?a=0..4.
 * - Si un joueur clique ?a=... sans p -> redirection vers son profil (token).
 * - Si p & a -> acte imposÃ© et â€œActe suivantâ€ cachÃ©.
 *
 * Mode test auto-hide :
 * - visible seulement en test (lien ?p=... sans ?a=)
 * - jamais visible en mode pilotÃ© (?a=)
 */
function loadPlayer(){
  const params = new URLSearchParams(location.search);
  const p = params.get("p");
  const a = params.get("a");
  const testBox = document.getElementById("testBox");

  if (p){
    localStorage.setItem(STORAGE_KEY, p);
    payload = b64uDecode(decodeURIComponent(p));

    document.getElementById("host").classList.add("hide");
    document.getElementById("player").classList.remove("hide");
    document.getElementById("pname").textContent = payload.n;

    if (a !== null) act = clamp(parseInt(a,10) || 0, 0, ACTS.length-1);
    renderAct();
    renderAllGrids();

    // Mode pilotÃ© : cache â€œActe suivantâ€
    if (a !== null){
      document.getElementById("btnNext").classList.add("hide");
    }

    // Auto-hide mode test
    if (testBox){
      if (a !== null) testBox.classList.add("hide");
      else testBox.classList.remove("hide");
    }

    return;
  }

  // lien de groupe ?a=...
  if (a !== null){
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved){
      const base = location.origin + location.pathname;
      location.replace(base + "?p=" + encodeURIComponent(saved) + "&a=" + encodeURIComponent(a));
    } else {
      alert("Ouvre dâ€™abord ton lien privÃ© (celui que lâ€™hÃ´te tâ€™a envoyÃ©), puis re-clique le lien de groupe.");
    }
    return;
  }

  // sinon : mode hÃ´te
}

/* ===================== Events ===================== */
document.getElementById("btnGen").addEventListener("click", generate);
document.getElementById("btnNext").addEventListener("click", nextAct);

document.getElementById("btnReset").addEventListener("click", () => {
  localStorage.removeItem(STORAGE_KEY);
  alert("Joueur effacÃ© âœ…\nTu peux maintenant ouvrir un autre lien joueur sur ce tÃ©lÃ©phone.");
  location.href = location.origin + location.pathname;
});

document.getElementById("btnAutoFromClues").addEventListener("click", () => {
  if (!payload) return;
  autoEliminateFromClues();
});

document.getElementById("btnClearGrid").addEventListener("click", () => {
  if (!payload) return;
  clearGrid();
});

loadPlayer();
</script>
</body>
</html>
