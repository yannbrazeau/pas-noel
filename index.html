<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NoÃ«l chez les Brazo â€” Le Dernier Convive (V2)</title>

<style>
:root{
  --bg1:#0b1430;
  --bg2:#1a0b1e;
  --paper:#fff7ee;
  --ink:#1b1b1b;
  --gold:#d6b25e;
  --red:#c41e3a;
  --green:#1f7a4d;
}
*{box-sizing:border-box}
body{
  margin:0;padding:18px;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
  color:#fff;
  background:
    radial-gradient(900px 600px at 20% 0%, rgba(214,178,94,.20), transparent 60%),
    radial-gradient(900px 700px at 80% 10%, rgba(196,30,58,.18), transparent 55%),
    radial-gradient(1200px 900px at 50% 110%, rgba(31,122,77,.18), transparent 60%),
    linear-gradient(180deg, var(--bg1), var(--bg2));
}
.wrap{max-width:860px;margin:0 auto}
.card{
  background:var(--paper); color:var(--ink);
  border-radius:22px; padding:18px;
  box-shadow:0 18px 40px rgba(0,0,0,.35);
  border:1px solid rgba(0,0,0,.06);
  position:relative; margin:0 auto 16px;
}
.card:after{
  content:""; position:absolute; inset:10px;
  border-radius:16px;
  border:1px solid rgba(214,178,94,.55);
  pointer-events:none;
}
h1,h2{margin:0 0 10px}
h1{font-size:28px}
h2{font-size:18px}
.small{opacity:.78;font-size:14px;line-height:1.35}
.hr{height:1px;background:rgba(0,0,0,.10);margin:12px 0;border-radius:999px}

textarea,button{
  width:100%;
  padding:12px;
  border-radius:14px;
  border:1px solid rgba(0,0,0,.14);
  font-size:16px;
  margin-top:10px;
  background:#fff;
  color:#111;
}
button{
  cursor:pointer;
  font-weight:900;
  border:none;
  color:#fff;
  background:linear-gradient(180deg,#2aa565,#167347);
  box-shadow:0 10px 22px rgba(31,122,77,.20);
}
button.secondary{
  background:linear-gradient(180deg,#d63a4f,#a9122b);
  box-shadow:0 10px 22px rgba(196,30,58,.18);
}
button.reset{
  background:linear-gradient(180deg,#2b4aa5,#19357a);
  box-shadow:0 10px 22px rgba(11,74,158,.18);
}

.box{
  margin-top:12px;
  padding:12px;
  border-radius:16px;
  background:rgba(0,0,0,.05);
  border:1px dashed rgba(196,30,58,.35);
}
.pill{
  display:inline-block;
  padding:6px 10px;
  border-radius:999px;
  background:rgba(214,178,94,.18);
  border:1px solid rgba(214,178,94,.45);
  font-size:13px;
  margin:6px 6px 0 0;
}
a{color:#0b4a9e;word-break:break-all}
.hide{display:none}
kbd{
  display:inline-block;
  padding:2px 7px;
  border-radius:8px;
  border:1px solid rgba(0,0,0,.12);
  background:rgba(255,255,255,.8);
  font-size:12px;
}
pre{
  margin:0;
  white-space:pre-wrap;
  font-family:inherit;
}
</style>
</head>

<body>
<div class="wrap">

  <!-- HOST -->
  <div class="card" id="host">
    <h1>ğŸ„ NoÃ«l chez les Brazo</h1>
    <h2>ğŸ•¯ï¸ Le Dernier Convive â€” V2</h2>

    <div class="small">
      1) Mets <b>7 Ã  9 prÃ©noms</b> (1 par ligne) <br>
      2) Clique <b>GÃ‰NÃ‰RER</b> <br>
      3) Envoie Ã  chacun son lien privÃ© (WhatsApp) <br>
      4) Pendant le repas, envoie dans le groupe les liens <b><kbd>?a=</kbd></b> (Acte I â†’ V) pour synchroniser tout le monde
      <div class="hr"></div>
      <b>RÃ¨gle dâ€™or :</b> personne ne montre son Ã©cran. Au dessert : accusations â†’ rÃ©vÃ©lation.
    </div>

    <textarea id="names" placeholder="Yann&#10;Delphine&#10;Maxime&#10;Louis&#10;Gabriel&#10;Juliette&#10;Baptiste"></textarea>
    <button id="btnGen">GÃ‰NÃ‰RER LA PARTIE</button>

    <div class="box">
      <h2>ğŸ”— Liens privÃ©s joueurs</h2>
      <div id="links" class="small">â€”</div>
      <div class="small" style="margin-top:8px;opacity:.85">
        âš ï¸ Chaque joueur doit ouvrir son lien privÃ© <b>au moins une fois</b> (Ã§a enregistre son accÃ¨s). Ensuite il pourra utiliser les liens de groupe.
      </div>
    </div>

    <div class="box">
      <h2>ğŸ“£ Liens de groupe (synchro des actes)</h2>
      <div id="actLinks" class="small">â€”</div>
    </div>

    <div class="box">
      <h2>ğŸ§© Solution (hÃ´te)</h2>
      <div id="solution" class="small">â€”</div>
      <div class="small" style="margin-top:8px">
        Ã€ dire au groupe : <b>â€œCâ€™est un Cluedo. Vous avez des indices privÃ©s. Au dessert, vous accusez.â€</b>
      </div>
    </div>
  </div>

  <!-- PLAYER -->
  <div class="card hide" id="player">
    <h1>ğŸ•¯ï¸ Le Dernier Convive</h1>
    <div class="small"><b>Joueur :</b> <span id="pname"></span> â€” Ne montre pas ton Ã©cran.</div>

    <div class="box">
      <h2>ğŸ­ Ton rÃ´le</h2>
      <div id="role" class="small">â€”</div>
      <div id="roleRule" class="small" style="margin-top:6px;opacity:.85">â€”</div>
    </div>

    <div class="box hide" id="killerBox">
      <h2>ğŸ”ª Ton objectif secret</h2>
      <div id="killerGoal" class="small"></div>
    </div>

    <div class="box">
      <h2 id="actTitle"></h2>
      <div id="story" class="small"></div>
    </div>

    <div class="box">
      <h2>ğŸ” Tes indices</h2>
      <pre id="clue" class="small"></pre>
    </div>

    <button class="secondary" id="btnNext">ACTE SUIVANT</button>

    <!-- MODE TEST (auto-hide : visible seulement en test, jamais en mode ?a= pilotÃ©) -->
    <div class="box hide" id="testBox">
      <h2>ğŸ§¼ Mode test</h2>
      <div class="small">
        Si tu testes plusieurs joueurs sur <b>le mÃªme tÃ©lÃ©phone</b>, efface le joueur enregistrÃ© ici.
      </div>
      <button class="reset" id="btnReset">EFFACER LE JOUEUR SUR CE TÃ‰LÃ‰PHONE</button>
    </div>
  </div>

</div>

<script>
/* ===================== Utils ===================== */
function b64uEncode(obj){
  const json = JSON.stringify(obj);
  const bytes = new TextEncoder().encode(json);
  let bin = "";
  for (const b of bytes) bin += String.fromCharCode(b);
  return btoa(bin);
}
function b64uDecode(str){
  const bin = atob(str);
  const bytes = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
  const json = new TextDecoder().decode(bytes);
  return JSON.parse(json);
}
function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }
function cleanNames(raw){
  // dÃ©doublonne en gardant lâ€™ordre (pratique si quelquâ€™un copie-colle)
  const out = [];
  const seen = new Set();
  raw.split("\n").map(s=>s.trim()).filter(Boolean).forEach(n=>{
    const key = n.toLowerCase();
    if (!seen.has(key)){ seen.add(key); out.push(n); }
  });
  return out;
}

/* ===================== Narratif V2 (commun) ===================== */
const ACTS = [
  ["ğŸ¥‚ Acte I â€” ApÃ©ro : Le masque social",
   "Les premiÃ¨res phrases tombent. Quelquâ€™un rÃ©pÃ¨te exactement les mots dâ€™un autre. Un test. Un miroir. La partie commence doucement."],
  ["ğŸ½ï¸ Acte II â€” EntrÃ©e : Quelque chose a bougÃ©",
   "Un objet nâ€™est plus lÃ  oÃ¹ il devrait Ãªtre. Personne ne lâ€™a vu disparaÃ®tre. Pourtant, quelquâ€™un sait exactement quand cela sâ€™est produit."],
  ["ğŸ Acte III â€” Plat : Trop en avance",
   "Une dÃ©fense arrive avant la phrase. Une micro-seconde dâ€™avance. Quelquâ€™un connaÃ®t dÃ©jÃ  la suite de la conversation."],
  ["ğŸ§€ Acte IV â€” Fromage : Le faux parfait",
   "Un indice apparaÃ®t. Trop propre. Trop Ã©vident. Quelquâ€™un lâ€™a dÃ©posÃ© pour Ãªtre trouvÃ©."],
  ["ğŸ° Acte V â€” Dessert : La vÃ©ritÃ© est une combinaison",
   "Il ne reste plus beaucoup de temps. Ce que tu nâ€™as pas Ã©liminÃ© est probablement la rÃ©ponseâ€¦ sauf si on tâ€™a guidÃ© vers une fausse piste."]
];

const WHERE = ["Cuisine","Couloir","Salon","Salle Ã  manger","Terrasse/Balcon","EntrÃ©e","Escalier/Palier","PrÃ¨s du frigo/bar","Point dâ€™eau/WC"];
const HOW   = ["Message anonyme","Substitution discrÃ¨te","Son/LumiÃ¨re dÃ©clenchÃ©","Mensonge rÃ©pÃ©tÃ©","Faux indice placÃ©","Regard orchestrÃ©","Rumeur soufflÃ©e","Disparition dâ€™objet","Mise en scÃ¨ne subtile"];

const ROLES = [
  { id:"observer",     label:"ğŸ•µï¸ Lâ€™Observateur",  rule:"Tu reÃ§ois un indice supplÃ©mentaire dÃ¨s lâ€™apÃ©ro. Observe les micro-rÃ©actions.", extraClue:true },
  { id:"silent",       label:"ğŸ¤ Le Silencieux",   rule:"Pendant lâ€™apÃ©ro, tu ne peux pas parler. Hoche la tÃªte, souris, mais silence.", silentAct:0 },
  { id:"manipulator",  label:"ğŸ­ Le Manipulateur", rule:"Tu as 1 indice volontairement faux (crÃ©dible). Utilise-le pour orienter le groupe.", fakeClue:true },
  { id:"confident",    label:"ğŸ•¯ï¸ Le Confident",    rule:"Une seule fois, tu peux montrer UN de tes indices Ã  quelquâ€™un. Choisis bien.", canShowOne:true },
  { id:"rusher",       label:"â³ Le PressÃ©",       rule:"Tu dois accuser avant le dessert. Sinon, tu perds (mÃªme si tu avais raison).", mustAccuseBeforeDessert:true }
];

const KILLER_GOALS = [
  "ÃŠtre accusÃ© par au moins 2 personnes.",
  "Faire accuser un innocent prÃ©cis.",
  "Ne jamais mentir explicitement (tu peux esquiver).",
  "Ne jamais Ãªtre nommÃ© avant le dessert."
];

const FLAVOR = [
  "ğŸ•¯ï¸ Quelquâ€™un Ã©vite ton regard au moment oÃ¹ tu parles.",
  "ğŸ•¯ï¸ Une rÃ©action trop rapide : comme si la rÃ©ponse Ã©tait prÃªte.",
  "ğŸ•¯ï¸ Tu entends une phrase rÃ©pÃ©tÃ©e Ã  lâ€™identique. Exactement.",
  "ğŸ•¯ï¸ Un silence tombe une demi-seconde trop tard.",
  "ğŸ•¯ï¸ Observe qui soutient quelle piste sans preuve.",
  "ğŸ•¯ï¸ Quelquâ€™un â€œdÃ©fendâ€ une idÃ©e quâ€™on nâ€™a pas encore formulÃ©e.",
  "ğŸ•¯ï¸ Une personne pose une questionâ€¦ puis semble regretter.",
  "ğŸ•¯ï¸ Le rÃ©cit le plus â€œpropreâ€ est parfois le plus fabriquÃ©."
];

const STORAGE_KEY = "dlc_player_token_v2";
let payload = null;
let act = 0;

/* ===================== Roles assignment ===================== */
function buildRoleMap(names, killerName){
  // nb rÃ´les spÃ©ciaux : 4 si 9 joueurs, 3 si 8, 2 si 7 (tu peux ajuster)
  const n = names.length;
  const specialCount = clamp(n - 5, 2, 4); // 7->2, 8->3, 9->4

  const chosen = shuffle([...ROLES]).slice(0, specialCount);

  const map = {};
  names.forEach(nm => map[nm] = { id:"detective", label:"ğŸ•¯ï¸ DÃ©tective", rule:"Tu as un puzzle partiel. Observe, recoupe, accuse au dessert." });

  const shuffledNames = shuffle([...names]);
  chosen.forEach((r, idx) => {
    map[shuffledNames[idx]] = r;
  });

  // Garde-fou : Ã©viter "Manipulateur" au tueur (souvent trop fort)
  if (map[killerName]?.id === "manipulator"){
    const detective = names.find(nm => nm !== killerName && map[nm].id === "detective");
    if (detective){
      map[killerName] = { id:"detective", label:"ğŸ•¯ï¸ DÃ©tective", rule:"Tu as un puzzle partiel. Observe, recoupe, accuse au dessert." };
      map[detective]  = ROLES.find(r=>r.id==="manipulator");
    }
  }

  return map;
}

/* ===================== Generation ===================== */
function generate(){
  const names = cleanNames(document.getElementById("names").value);

  if (names.length < 7 || names.length > 9){
    alert("Il faut entre 7 et 9 prÃ©noms (lignes non vides).");
    return;
  }

  const killer = shuffle([...names])[0];
  const where  = shuffle([...WHERE])[0];
  const how    = shuffle([...HOW])[0];

  // Fausse piste complÃ¨te (crÃ©dible)
  const fakeKiller = shuffle(names.filter(n=>n!==killer))[0];
  const fakeWhere  = pick(WHERE.filter(w=>w!==where));
  const fakeHow    = pick(HOW.filter(h=>h!==how));

  document.getElementById("solution").innerHTML =
    `<b>ğŸ”ª ${killer}</b><br>ğŸ“ ${where}<br>ğŸ› ï¸ ${how}<br>
     <div class="small" style="margin-top:6px;opacity:.85">Fausse piste interne : ${fakeKiller} / ${fakeWhere} / ${fakeHow} (ne pas dire)</div>
     <span class="small">Ne rÃ©vÃ¨le quâ€™au dessert.</span>`;

  // Deck d'exclusions (tout sauf la solution)
  const deck = [];
  for (const n of names) if (n !== killer) deck.push(`âŒ Ce nâ€™est pas ${n}`);
  for (const w of WHERE) if (w !== where)  deck.push(`âŒ Pas ${w}`);
  for (const h of HOW)   if (h !== how)    deck.push(`âŒ Pas ${h}`);

  // Faux indices (orientent vers la fausse piste)
  const fakeDeck = [
    `âŒ Ce nâ€™est pas ${fakeKiller}`,
    `âŒ Pas ${fakeWhere}`,
    `âŒ Pas ${fakeHow}`
  ];

  shuffle(deck);

  // Base URL
  const base = location.origin + location.pathname;

  // Liens de groupe (actes)
  const actLinks = ACTS.map((a, idx) => {
    const url = base + "?a=" + idx;
    return `<div class="pill">${a[0]}</div><div><a href="${url}">${url}</a></div><br>`;
  }).join("");
  document.getElementById("actLinks").innerHTML = actLinks;

  // RÃ´les
  const roleMap = buildRoleMap(names, killer);

  // Objectif du tueur
  const killerGoal = pick(KILLER_GOALS);

  // Distribution d'indices : 2 par acte par joueur (donc 10 par joueur)
  const players = names.length;
  const cardsPerPlayer = ACTS.length * 2; // 10
  const totalCardsNeeded = players * cardsPerPlayer;

  let mega = [...deck];

  // On complÃ¨te avec flavor pour atteindre le bon volume
  while (mega.length < totalCardsNeeded) mega.push(pick(FLAVOR));
  shuffle(mega);

  // DÃ©coupe des mains
  const hands = {};
  names.forEach((nm, i) => {
    hands[nm] = mega.slice(i*cardsPerPlayer, i*cardsPerPlayer + cardsPerPlayer);
  });

  // Manipulateur reÃ§oit au moins 1 faux indice Ã  l'acte II (index 2)
  const manipName = names.find(nm => roleMap[nm]?.id === "manipulator");
  if (manipName){
    const idx = 2; // 1Ã¨re carte de l'acte II
    hands[manipName][idx] = pick(fakeDeck);
  }

  // Observateur : bonus Ã  lâ€™acte I
  const observerBonus = pick(deck.length ? deck : FLAVOR);

  // Liens privÃ©s joueurs
  let linksHTML = "";
  names.forEach((nm)=>{
    const role = roleMap[nm];

    // 2 indices par acte
    const handFlat = hands[nm];
    const perAct = [];
    for (let a=0; a<ACTS.length; a++){
      perAct.push([handFlat[a*2], handFlat[a*2+1]].filter(Boolean));
    }

    const dataObj = {
      v: 2,
      n: nm,
      role,
      hand: perAct,
      killer: (nm === killer),
      killerGoal: (nm === killer) ? killerGoal : null,
      observerBonus: (role.id === "observer") ? observerBonus : null
    };

    const data = b64uEncode(dataObj);
    const url  = base + "?p=" + encodeURIComponent(data);

    linksHTML += `<div class="pill">${nm}</div><div><a href="${url}">${url}</a></div><br>`;
  });

  document.getElementById("links").innerHTML = linksHTML;
}

/* ===================== Player render ===================== */
function renderAct(){
  document.getElementById("actTitle").textContent = ACTS[act][0];
  document.getElementById("story").textContent    = ACTS[act][1];

  document.getElementById("role").textContent = payload.role?.label || "ğŸ•¯ï¸ DÃ©tective";
  document.getElementById("roleRule").textContent = payload.role?.rule || "";

  if (payload.killer){
    document.getElementById("killerBox").classList.remove("hide");
    document.getElementById("killerGoal").textContent = payload.killerGoal || "â€”";
  } else {
    document.getElementById("killerBox").classList.add("hide");
  }

  // Indices : 2 par acte + bonus observateur Ã  lâ€™acte I
  const clues = (payload.hand && payload.hand[act]) ? payload.hand[act] : [];
  let lines = [];

  if (!clues.length){
    lines.push("Pas dâ€™indice personnel Ã  cet acte. Observe ğŸ™‚");
  } else {
    clues.forEach(c => lines.push("â€¢ " + c));
  }

  if (payload.role?.id === "observer" && act === 0 && payload.observerBonus){
    lines.push("");
    lines.push("ğŸ•µï¸ Bonus Observateur :");
    lines.push("â€¢ " + payload.observerBonus);
  }

  // RÃ¨gle Silencieux (acte I)
  if (payload.role?.id === "silent" && act === 0){
    document.getElementById("roleRule").textContent =
      "ğŸ¤ Pendant lâ€™apÃ©ro, tu ne peux pas parler. Tu peux sourire, acquiescer, mais silence total.";
  }

  document.getElementById("clue").textContent = lines.join("\n");
}

function nextAct(){
  if (act < ACTS.length - 1){
    act++;
    renderAct();
  } else {
    alert("Dernier acte. Fais ton accusation finale, puis attends la rÃ©vÃ©lation de lâ€™hÃ´te ğŸ•¯ï¸");
  }
}

/**
 * Mode synchro sans serveur :
 * - Le joueur ouvre 1 fois son lien privÃ© ?p=... -> on stocke le token localement.
 * - L'hÃ´te envoie au groupe des liens ?a=0..4.
 * - Si un joueur clique ?a=... (sans p), on le redirige vers sa page (token stockÃ©) + &a=.
 * - Si p ET a -> on force lâ€™acte et on cache â€œActe suivantâ€.
 *
 * Auto-hide "Mode test" :
 * - visible seulement quand on ouvre un lien joueur ?p=... SANS ?a=
 * - jamais visible en mode pilotÃ© (?a=), donc pas de tentation pendant le dÃ®ner.
 */
function loadPlayer(){
  const params = new URLSearchParams(location.search);
  const p = params.get("p");
  const a = params.get("a");
  const testBox = document.getElementById("testBox");

  // Si le joueur ouvre son lien privÃ© : on stocke le token
  if (p){
    localStorage.setItem(STORAGE_KEY, p);
    payload = b64uDecode(decodeURIComponent(p));

    document.getElementById("host").classList.add("hide");
    document.getElementById("player").classList.remove("hide");
    document.getElementById("pname").textContent = payload.n;

    // Si un acte est imposÃ©, on s'aligne
    if (a !== null) act = clamp(parseInt(a,10) || 0, 0, ACTS.length-1);
    renderAct();

    // Mode pilotÃ© : cache le bouton "Acte suivant"
    if (a !== null){
      document.getElementById("btnNext").classList.add("hide");
    }

    // Auto-hide mode test : visible seulement en mode test (pas de ?a=)
    if (testBox){
      if (a !== null) testBox.classList.add("hide");
      else testBox.classList.remove("hide");
    }

    return;
  }

  // Si lien de groupe ?a=... sans p : redirection vers la page perso via token stockÃ©
  if (a !== null){
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved){
      const base = location.origin + location.pathname;
      location.replace(base + "?p=" + encodeURIComponent(saved) + "&a=" + encodeURIComponent(a));
      return;
    } else {
      alert("Ouvre dâ€™abord ton lien privÃ© (celui que lâ€™hÃ´te tâ€™a envoyÃ©), puis re-clique le lien de groupe.");
      return;
    }
  }

  // sinon : mode hÃ´te
}

/* ===================== Events ===================== */
document.getElementById("btnGen").addEventListener("click", generate);
document.getElementById("btnNext").addEventListener("click", nextAct);

document.getElementById("btnReset").addEventListener("click", () => {
  localStorage.removeItem(STORAGE_KEY);
  alert("Joueur effacÃ© âœ…\nTu peux maintenant ouvrir un autre lien joueur sur ce tÃ©lÃ©phone.");
  location.href = location.origin + location.pathname;
});

loadPlayer();
</script>
</body>
</html>
