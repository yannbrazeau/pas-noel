<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NoÃ«l chez les Brazo â€” Le Dernier Convive (V2)</title>

<style>
:root{
  --bg1:#0b1430;
  --bg2:#1a0b1e;
  --paper:#fff7ee;
  --ink:#1b1b1b;
  --gold:#d6b25e;
  --red:#c41e3a;
  --green:#1f7a4d;
}

*{box-sizing:border-box}

body{
  margin:0;
  padding:18px;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
  color:#fff;
  background:
    radial-gradient(900px 600px at 20% 0%, rgba(214,178,94,.20), transparent 60%),
    radial-gradient(900px 700px at 80% 10%, rgba(196,30,58,.18), transparent 55%),
    radial-gradient(1200px 900px at 50% 110%, rgba(31,122,77,.18), transparent 60%),
    linear-gradient(180deg, var(--bg1), var(--bg2));
}

.wrap{max-width:860px;margin:0 auto}

.card{
  background:var(--paper);
  color:var(--ink);
  border-radius:22px;
  padding:18px;
  box-shadow:0 18px 40px rgba(0,0,0,.35);
  border:1px solid rgba(0,0,0,.06);
  position:relative;
  margin:0 auto 16px;
}

.card:after{
  content:"";
  position:absolute;
  inset:10px;
  border-radius:16px;
  border:1px solid rgba(214,178,94,.55);
  pointer-events:none;
}

h1,h2{margin:0 0 10px}
h1{font-size:28px}
h2{font-size:18px}
.small{opacity:.78;font-size:14px;line-height:1.35}
.hr{height:1px;background:rgba(0,0,0,.10);margin:12px 0;border-radius:999px}

textarea,button,select{
  width:100%;
  padding:12px;
  border-radius:14px;
  border:1px solid rgba(0,0,0,.14);
  font-size:16px;
  margin-top:10px;
  background:#fff;
  color:#111;
}

button{
  cursor:pointer;
  font-weight:900;
  border:none;
  color:#fff;
  background:linear-gradient(180deg,#2aa565,#167347);
  box-shadow:0 10px 22px rgba(31,122,77,.20);
}
button.secondary{
  background:linear-gradient(180deg,#d63a4f,#a9122b);
  box-shadow:0 10px 22px rgba(196,30,58,.18);
}

.box{
  margin-top:12px;
  padding:12px;
  border-radius:16px;
  background:rgba(0,0,0,.05);
  border:1px dashed rgba(196,30,58,.35);
}

.pill{
  display:inline-block;
  padding:6px 10px;
  border-radius:999px;
  background:rgba(214,178,94,.18);
  border:1px solid rgba(214,178,94,.45);
  font-size:13px;
  margin:6px 6px 0 0;
}

a{color:#0b4a9e;word-break:break-all}
.hide{display:none}

/* Forcer la saisie au-dessus de tout */
textarea,button,select{position:relative; z-index:5; pointer-events:auto}

kbd{
  display:inline-block;
  padding:2px 7px;
  border-radius:8px;
  border:1px solid rgba(0,0,0,.12);
  background:rgba(255,255,255,.8);
  font-size:12px;
}
</style>
</head>

<body>
<div class="wrap">

  <!-- HOST -->
  <div class="card" id="host">
    <h1>ğŸ„ NoÃ«l chez les Brazo</h1>
    <h2>ğŸ•¯ï¸ Le Dernier Convive â€” V2</h2>
    <div class="small">
      1) Mets <b>exactement 9 prÃ©noms</b> (1 par ligne) <br>
      2) Clique <b>GÃ‰NÃ‰RER</b> <br>
      3) Envoie Ã  chacun son lien privÃ© (WhatsApp) <br>
      4) <b>Pour synchroniser</b>, envoie ensuite au groupe les liens â€œActeâ€ (<kbd>?a=</kbd>) au bon moment.
      <div class="hr"></div>
      <b>RÃ¨gle dâ€™or :</b> personne ne montre son Ã©cran. Au dessert : accusations â†’ rÃ©vÃ©lation.
    </div>

    <textarea id="names" placeholder="Yann&#10;Delphine&#10;Maxime&#10;Louis&#10;Gabriel&#10;Juliette&#10;Baptiste&#10;... (9 lignes)"></textarea>
    <button id="btnGen">GÃ‰NÃ‰RER LA PARTIE</button>

    <div class="box">
      <h2>ğŸ”— Liens privÃ©s joueurs</h2>
      <div id="links" class="small">â€”</div>
      <div class="small" style="margin-top:8px;opacity:.85">
        âš ï¸ Chaque joueur doit ouvrir son lien privÃ© <b>au moins une fois</b> (Ã§a enregistre son accÃ¨s). Ensuite, il pourra utiliser les liens de groupe.
      </div>
    </div>

    <div class="box">
      <h2>ğŸ“£ Liens de groupe (synchro des actes)</h2>
      <div id="actLinks" class="small">â€”</div>
      <div class="small" style="margin-top:8px;opacity:.85">
        Ã€ envoyer dans le groupe WhatsApp Ã  chaque Ã©tape : tout le monde verra <b>le mÃªme narratif</b> au mÃªme moment.
      </div>
    </div>

    <div class="box">
      <h2>ğŸ§© Solution (hÃ´te)</h2>
      <div id="solution" class="small">â€”</div>
      <div class="small" style="margin-top:8px">
        Ã€ dire au groupe : <b>â€œCâ€™est un Cluedo. Vous avez des indices privÃ©s. Au dessert, vous accusez.â€</b>
      </div>
    </div>
  </div>

  <!-- PLAYER -->
  <div class="card hide" id="player">
    <h1>ğŸ•¯ï¸ Le Dernier Convive</h1>
    <div class="small"><b>Joueur :</b> <span id="pname"></span> â€” Ne montre pas ton Ã©cran.</div>

    <div class="box">
      <h2>ğŸ­ Ton rÃ´le</h2>
      <div id="role" class="small">â€”</div>
      <div id="roleRule" class="small" style="margin-top:6px;opacity:.85">â€”</div>
    </div>

    <div class="box hide" id="killerBox">
      <h2>ğŸ”ª Ton objectif secret</h2>
      <div id="killerGoal" class="small"></div>
    </div>

    <div class="box">
      <h2 id="actTitle"></h2>
      <div id="story" class="small"></div>
    </div>

    <div class="box">
      <h2>ğŸ” Ton indice</h2>
      <div id="clue" class="small"></div>
    </div>

    <button class="secondary" id="btnNext">ACTE SUIVANT</button>
  </div>

</div>

<script>
/* Base64 UTF-8 safe (rÃ©sout les accents / â€™ / etc.) */
function b64uEncode(obj){
  const json = JSON.stringify(obj);
  const bytes = new TextEncoder().encode(json);
  let bin = "";
  for (const b of bytes) bin += String.fromCharCode(b);
  return btoa(bin);
}
function b64uDecode(str){
  const bin = atob(str);
  const bytes = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
  const json = new TextDecoder().decode(bytes);
  return JSON.parse(json);
}

/* Narratif V2 (commun) */
const ACTS = [
  ["ğŸ¥‚ Acte I â€” ApÃ©ro : Le masque social",
   "Les premiÃ¨res phrases tombent. Quelquâ€™un rÃ©pÃ¨te exactement les mots dâ€™un autre. Un test. Un miroir. La partie commence doucement."],
  ["ğŸ½ï¸ Acte II â€” EntrÃ©e : Quelque chose a bougÃ©",
   "Un objet nâ€™est plus lÃ  oÃ¹ il devrait Ãªtre. Personne ne lâ€™a vu disparaÃ®tre. Pourtant, quelquâ€™un sait exactement quand cela sâ€™est produit."],
  ["ğŸ Acte III â€” Plat : Trop en avance",
   "Une dÃ©fense arrive avant la phrase. Une micro-seconde dâ€™avance. Quelquâ€™un connaÃ®t dÃ©jÃ  la suite de la conversation."],
  ["ğŸ§€ Acte IV â€” Fromage : Le faux parfait",
   "Un indice apparaÃ®t. Trop propre. Trop Ã©vident. Quelquâ€™un lâ€™a dÃ©posÃ© pour Ãªtre trouvÃ©."],
  ["ğŸ° Acte V â€” Dessert : La vÃ©ritÃ© est une combinaison",
   "Il ne reste plus beaucoup de temps. Ce que tu nâ€™as pas Ã©liminÃ© est probablement la rÃ©ponseâ€¦ sauf si on tâ€™a guidÃ© vers une fausse piste."]
];

/* Lieux / moyens */
const WHERE = ["Cuisine","Couloir","Salon","Salle Ã  manger","Terrasse/Balcon","EntrÃ©e","Escalier/Palier","PrÃ¨s du frigo/bar","Point dâ€™eau/WC"];
const HOW   = ["Message anonyme","Substitution discrÃ¨te","Son/LumiÃ¨re dÃ©clenchÃ©","Mensonge rÃ©pÃ©tÃ©","Faux indice placÃ©","Regard orchestrÃ©","Rumeur soufflÃ©e","Disparition dâ€™objet","Mise en scÃ¨ne subtile"];

/* RÃ´les (on en assigne 4, les autres = DÃ©tective) */
const ROLES = [
  { id:"observer",     label:"ğŸ•µï¸ Lâ€™Observateur",   rule:"Tu reÃ§ois un indice supplÃ©mentaire dÃ¨s lâ€™apÃ©ro. Observe les micro-rÃ©actions.", extraClue:true },
  { id:"silent",       label:"ğŸ¤ Le Silencieux",    rule:"Pendant lâ€™apÃ©ro, tu ne peux pas parler. Hoche la tÃªte, souris, mais silence.", silentAct:0 },
  { id:"manipulator",  label:"ğŸ­ Le Manipulateur",  rule:"Tu as 1 indice volontairement faux (crÃ©dible). Utilise-le pour orienter le groupe.", fakeClue:true },
  { id:"confident",    label:"ğŸ•¯ï¸ Le Confident",     rule:"Une seule fois, tu peux montrer UN de tes indices Ã  quelquâ€™un. Choisis bien.", canShowOne:true },
  { id:"rusher",       label:"â³ Le PressÃ©",        rule:"Tu dois accuser avant le dessert. Sinon, tu perds (mÃªme si tu avais raison).", mustAccuseBeforeDessert:true }
];

const KILLER_GOALS = [
  "ÃŠtre accusÃ© par au moins 2 personnes.",
  "Faire accuser un innocent prÃ©cis.",
  "Ne jamais mentir explicitement (tu peux esquiver).",
  "Ne jamais Ãªtre nommÃ© avant le dessert."
];

let payload = null;
let act = 0;

function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}
function cleanNames(raw){
  return raw.split("\n").map(s=>s.trim()).filter(Boolean);
}
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

function buildRoleMap(names, killerName){
  // On assigne 4 rÃ´les Ã  4 joueurs (au hasard). Les autres = DÃ©tective.
  const chosen = shuffle([...ROLES]).slice(0,4);
  const shuffledNames = shuffle([...names]);

  const map = {};
  shuffledNames.forEach(n => map[n] = { id:"detective", label:"ğŸ•¯ï¸ DÃ©tective", rule:"Tu as un puzzle partiel. Observe, recoupe, accuse au dessert." });

  // Option : Ã©viter de donner "Manipulateur" au tueur (c'est dÃ©jÃ  assez puissant). Si Ã§a tombe, on permute.
  let roleNames = shuffle([...shuffledNames]);
  chosen.forEach((r, idx) => {
    let name = roleNames[idx];
    map[name] = r;
  });

  // Petit garde-fou : si le tueur a "manipulator", on Ã©change avec un dÃ©tective.
  if (map[killerName]?.id === "manipulator") {
    const detective = names.find(n => n !== killerName && map[n].id === "detective");
    if (detective) {
      map[killerName] = { id:"detective", label:"ğŸ•¯ï¸ DÃ©tective", rule:"Tu as un puzzle partiel. Observe, recoupe, accuse au dessert." };
      map[detective]  = ROLES.find(r=>r.id==="manipulator");
    }
  }
  return map;
}

function generate(){
  const names = cleanNames(document.getElementById("names").value);
  if (names.length !== 9){
    alert("Il faut exactement 9 prÃ©noms (9 lignes non vides).");
    return;
  }

  const killer = shuffle([...names])[0];
  const where  = pick(WHERE);
  const how    = pick(HOW);

  // Fausse piste complÃ¨te (crÃ©dible)
  const fakeKiller = shuffle(names.filter(n=>n!==killer))[0];
  const fakeWhere  = pick(WHERE.filter(w=>w!==where));
  const fakeHow    = pick(HOW.filter(h=>h!==how));

  document.getElementById("solution").innerHTML =
    `<b>ğŸ”ª ${killer}</b><br>ğŸ“ ${where}<br>ğŸ› ï¸ ${how}<br><div class="small" style="margin-top:6px;opacity:.85">Fausse piste interne : ${fakeKiller} / ${fakeWhere} / ${fakeHow} (ne pas dire)</div><span class="small">Ne rÃ©vÃ¨le quâ€™au dessert.</span>`;

  // Deck d'exclusions (tout sauf la solution)
  const deck = [];
  for (const n of names) if (n !== killer) deck.push(`âŒ Ce nâ€™est pas ${n}`);
  for (const w of WHERE) if (w !== where)  deck.push(`âŒ Pas ${w}`);
  for (const h of HOW)   if (h !== how)    deck.push(`âŒ Pas ${h}`);

  // Deck de "faux indices" (ils orientent vers la fausse piste)
  // Important : ce sont aussi des exclusions, donc "crÃ©dibles" et difficiles Ã  dÃ©tecter.
  const fakeDeck = [
    `âŒ Ce nâ€™est pas ${fakeKiller}`,
    `âŒ Pas ${fakeWhere}`,
    `âŒ Pas ${fakeHow}`
  ];

  shuffle(deck);

  // Base URL
  const base = location.origin + location.pathname;

  // Liens de groupe (actes) pour piloter la synchro
  const actLinks = ACTS.map((a, idx) => {
    const url = base + "?a=" + idx;
    return `<div class="pill">${a[0]}</div><div><a href="${url}">${url}</a></div><br>`;
  }).join("");
  document.getElementById("actLinks").innerHTML = actLinks;

  // Attribution des rÃ´les (avec garde-fou)
  const roleMap = buildRoleMap(names, killer);

  // Objectif secret du tueur
  const killerGoal = pick(KILLER_GOALS);

  // Construction des mains : 2 indices par acte (pour exploiter plus du deck)
  // Total souhaitÃ©: 9 joueurs * 5 actes * 2 = 90 cartes.
  // Notre deck "exclusions" fait 8 + 8 + 8 = 24 (car 9 noms -> 8 exclusions, idem lieux/moyens).
  // Donc on va complÃ©ter avec des phrases "ambiance" non Ã©liminatoires (mais informatives/roleplay).
  const FLAVOR = [
    "ğŸ•¯ï¸ Quelquâ€™un Ã©vite ton regard au moment oÃ¹ tu parles.",
    "ğŸ•¯ï¸ Une rÃ©action trop rapide : comme si la rÃ©ponse Ã©tait prÃªte.",
    "ğŸ•¯ï¸ Tu entends une phrase rÃ©pÃ©tÃ©e Ã  lâ€™identique. Exactement.",
    "ğŸ•¯ï¸ Un silence tombe une demi-seconde trop tard.",
    "ğŸ•¯ï¸ Observe qui soutient quelle piste sans preuve.",
    "ğŸ•¯ï¸ Quelquâ€™un â€œdÃ©fendâ€ une idÃ©e quâ€™on nâ€™a pas encore formulÃ©e."
  ];

  // On crÃ©e un mega-deck: exclusions + quelques flavor + faux indices (injectÃ©s ensuite au besoin)
  let mega = [...deck];
  while (mega.length < 90) mega.push(pick(FLAVOR));
  shuffle(mega);

  // Distribution : 10 cartes par joueur (2 cartes x 5 actes) = 10
  const hands = {};
  names.forEach((n, i) => {
    hands[n] = mega.slice(i*10, i*10 + 10);
  });

  // RÃ¨gles V2 : Manipulateur reÃ§oit au moins 1 faux indice crÃ©dible
  const manipName = names.find(n => roleMap[n]?.id === "manipulator");
  if (manipName) {
    // On remplace une des cartes de son acte II (index 2 ou 3) par un faux indice
    const idx = 2; // premiÃ¨re carte de l'acte II dans la main (0-1 acte I, 2-3 acte II, etc.)
    hands[manipName][idx] = pick(fakeDeck);
  }

  // Observateur : reÃ§oit une carte bonus Ã  lâ€™acte I (on la met dans une â€œslotâ€ dÃ©diÃ©e)
  // Pour rester simple cÃ´tÃ© UI, on lâ€™affichera comme â€œbonusâ€ en plus de lâ€™indice normal.
  const observerName = names.find(n => roleMap[n]?.id === "observer");
  const observerBonus = observerName ? pick(deck.length ? deck : FLAVOR) : null;

  // GÃ©nÃ©ration des liens privÃ©s joueurs
  let linksHTML = "";
  names.forEach((n)=>{
    const role = roleMap[n];

    const hand10 = hands[n];
    // 2 indices par acte
    const perAct = [];
    for (let a=0; a<ACTS.length; a++){
      perAct.push([hand10[a*2], hand10[a*2+1]].filter(Boolean));
    }

    const dataObj = {
      v: 2,
      n,
      role,
      hand: perAct,
      killer: (n === killer),
      killerGoal: (n === killer) ? killerGoal : null,
      observerBonus: (role.id === "observer") ? observerBonus : null
    };

    const data = b64uEncode(dataObj);
    const url  = base + "?p=" + encodeURIComponent(data);

    linksHTML += `<div class="pill">${n}</div><div><a href="${url}">${url}</a></div><br>`;
  });

  document.getElementById("links").innerHTML = linksHTML;
}

function renderAct(){
  document.getElementById("actTitle").textContent = ACTS[act][0];
  document.getElementById("story").textContent    = ACTS[act][1];

  // RÃ´le
  document.getElementById("role").textContent = payload.role?.label || "ğŸ•¯ï¸ DÃ©tective";
  document.getElementById("roleRule").textContent = payload.role?.rule || "";

  // Objectif tueur
  if (payload.killer){
    document.getElementById("killerBox").classList.remove("hide");
    document.getElementById("killerGoal").textContent = payload.killerGoal || "â€”";
  } else {
    document.getElementById("killerBox").classList.add("hide");
  }

  // Indices : 2 par acte + bonus observateur Ã  lâ€™acte I
  const clues = (payload.hand && payload.hand[act]) ? payload.hand[act] : [];
  let txt = "";
  if (!clues.length) {
    txt = "Pas dâ€™indice personnel Ã  cet acte. Observe ğŸ™‚";
  } else if (clues.length === 1) {
    txt = clues[0];
  } else {
    txt = `â€¢ ${clues[0]}\nâ€¢ ${clues[1]}`;
  }

  // Bonus observateur Ã  lâ€™acte I
  if (payload.role?.id === "observer" && act === 0 && payload.observerBonus){
    txt += `\n\nğŸ•µï¸ Bonus Observateur :\nâ€¢ ${payload.observerBonus}`;
  }

  document.getElementById("clue").textContent = txt;

  // RÃ¨gle Silencieux Ã  lâ€™apÃ©ro
  if (payload.role?.id === "silent" && act === 0){
    document.getElementById("roleRule").textContent =
      "ğŸ¤ Pendant lâ€™apÃ©ro, tu ne peux pas parler. Tu peux sourire, acquiescer, mais silence total.";
  }
}

function nextAct(){
  if (act < ACTS.length - 1){
    act++;
    renderAct();
  } else {
    alert("Dernier acte. Fais ton accusation finale, puis attends la rÃ©vÃ©lation de lâ€™hÃ´te ğŸ•¯ï¸");
  }
}

/**
 * Mode synchro sans serveur :
 * - Le joueur ouvre 1 fois son lien privÃ© ?p=... -> on stocke le token localement.
 * - L'hÃ´te envoie au groupe des liens ?a=0..4.
 * - Si un joueur clique ?a=... (sans p), on le redirige vers sa page (token stockÃ©) + &a=.
 * - Si p ET a -> on force lâ€™acte et on cache â€œActe suivantâ€.
 */
function loadPlayer(){
  const params = new URLSearchParams(location.search);
  const p = params.get("p");
  const a = params.get("a");

  // Si le joueur ouvre son lien privÃ© : on stocke le token
  if (p) {
    localStorage.setItem("dlc_player_token_v2", p);
    payload = b64uDecode(decodeURIComponent(p));

    document.getElementById("host").classList.add("hide");
    document.getElementById("player").classList.remove("hide");
    document.getElementById("pname").textContent = payload.n;

    // Si un acte est imposÃ©, on s'aligne
    if (a !== null) act = Math.max(0, Math.min(ACTS.length - 1, parseInt(a, 10) || 0));
    renderAct();

    // Mode pilotÃ© par lâ€™hÃ´te : on cache le bouton â€œActe suivantâ€
    if (a !== null) {
      document.getElementById("btnNext").classList.add("hide");
      const note = document.createElement("div");
      note.className = "small";
      note.style.marginTop = "10px";
      note.style.opacity = ".85";
      note.textContent = "ğŸ“£ Acte pilotÃ© par lâ€™hÃ´te â€” attends le prochain lien WhatsApp.";
      document.getElementById("player").appendChild(note);
    }
    return;
  }

  // Si lien de groupe ?a=... sans p : redirection vers la page perso via token stockÃ©
  if (a !== null) {
    const saved = localStorage.getItem("dlc_player_token_v2");
    if (saved) {
      const base = location.origin + location.pathname;
      location.replace(base + "?p=" + encodeURIComponent(saved) + "&a=" + encodeURIComponent(a));
      return;
    } else {
      alert("Ouvre dâ€™abord ton lien privÃ© (celui que lâ€™hÃ´te tâ€™a envoyÃ©), puis re-clique le lien de groupe.");
      return;
    }
  }

  // sinon : mode hÃ´te
}

document.getElementById("btnGen").addEventListener("click", generate);
document.getElementById("btnNext").addEventListener("click", nextAct);
loadPlayer();
</script>
</body>
</html>
